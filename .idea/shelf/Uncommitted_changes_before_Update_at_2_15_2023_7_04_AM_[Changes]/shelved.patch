Index: src/App.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import React, { useLayoutEffect, useState } from \"react\";\r\nimport rough from \"roughjs/bundled/rough.esm\";\r\n\r\nconst generator = rough.generator();\r\n\r\nconst createElement = (id, x1, y1, x2, y2, type) => {\r\n  switch (type) {\r\n    case \"line\":\r\n    case \"rectangle\":\r\n      const roughElement =\r\n        type === \"line\"\r\n          ? generator.line(x1, y1, x2, y2)\r\n          : generator.rectangle(x1, y1, x2 - x1, y2 - y1);\r\n      return { id, x1, y1, x2, y2, type, roughElement };\r\n    case \"pencil\":\r\n      return { id, type, points: [{ x: x1, y: y1 }] };\r\n    case \"text\":\r\n      return { id, type, x1, y1, x2, y2, text: \"\" };\r\n    default:\r\n      throw new Error(`Type not recognised: ${type}`);\r\n  }\r\n};\r\n\r\nconst nearPoint = (x, y, x1, y1, name) => {\r\n  return Math.abs(x - x1) < 5 && Math.abs(y - y1) < 5 ? name : null;\r\n};\r\n\r\nconst onLine = (x1, y1, x2, y2, x, y, maxDistance = 1) => {\r\n  const a = { x: x1, y: y1 };\r\n  const b = { x: x2, y: y2 };\r\n  const c = { x, y };\r\n  const offset = distance(a, b) - (distance(a, c) + distance(b, c));\r\n  return Math.abs(offset) < maxDistance ? \"inside\" : null;\r\n};\r\n\r\nconst positionWithinElement = (x, y, element) => {\r\n  const { type, x1, x2, y1, y2 } = element;\r\n  switch (type) {\r\n    case \"line\":\r\n      const on = onLine(x1, y1, x2, y2, x, y);\r\n      const start = nearPoint(x, y, x1, y1, \"start\");\r\n      const end = nearPoint(x, y, x2, y2, \"end\");\r\n      return start || end || on;\r\n    case \"rectangle\":\r\n      const topLeft = nearPoint(x, y, x1, y1, \"tl\");\r\n      const topRight = nearPoint(x, y, x2, y1, \"tr\");\r\n      const bottomLeft = nearPoint(x, y, x1, y2, \"bl\");\r\n      const bottomRight = nearPoint(x, y, x2, y2, \"br\");\r\n      const inside = x >= x1 && x <= x2 && y >= y1 && y <= y2 ? \"inside\" : null;\r\n      return topLeft || topRight || bottomLeft || bottomRight || inside;\r\n    case \"pencil\":\r\n      const betweenAnyPoint = element.points.some((point, index) => {\r\n        const nextPoint = element.points[index + 1];\r\n        if (!nextPoint) return false;\r\n        return (\r\n          onLine(point.x, point.y, nextPoint.x, nextPoint.y, x, y, 5) != null\r\n        );\r\n      });\r\n      return betweenAnyPoint ? \"inside\" : null;\r\n    case \"text\":\r\n      return x >= x1 && x <= x2 && y >= y1 && y <= y2 ? \"inside\" : null;\r\n    default:\r\n      throw new Error(`Type not recognised: ${type}`);\r\n  }\r\n};\r\n\r\nconst distance = (a, b) =>\r\n  Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\r\n\r\nconst getElementAtPosition = (x, y, elements) => {\r\n  return elements\r\n    .map((element) => ({\r\n      ...element,\r\n      position: positionWithinElement(x, y, element),\r\n    }))\r\n    .find((element) => element.position !== null);\r\n};\r\n\r\nconst adjustElementCoordinates = (element) => {\r\n  const { type, x1, y1, x2, y2 } = element;\r\n  if (type === \"rectangle\") {\r\n    const minX = Math.min(x1, x2);\r\n    const maxX = Math.max(x1, x2);\r\n    const minY = Math.min(y1, y2);\r\n    const maxY = Math.max(y1, y2);\r\n    return { x1: minX, y1: minY, x2: maxX, y2: maxY };\r\n  } else {\r\n    if (x1 < x2 || (x1 === x2 && y1 < y2)) {\r\n      return { x1, y1, x2, y2 };\r\n    } else {\r\n      return { x1: x2, y1: y2, x2: x1, y2: y1 };\r\n    }\r\n  }\r\n};\r\n\r\nconst cursorForPosition = (position) => {\r\n  switch (position) {\r\n    case \"tl\":\r\n    case \"br\":\r\n    case \"start\":\r\n    case \"end\":\r\n      return \"nwse-resize\";\r\n    case \"tr\":\r\n    case \"bl\":\r\n      return \"nesw-resize\";\r\n    default:\r\n      return \"move\";\r\n  }\r\n};\r\n\r\nconst resizedCoordinates = (clientX, clientY, position, coordinates) => {\r\n  const { x1, y1, x2, y2 } = coordinates;\r\n  switch (position) {\r\n    case \"tl\":\r\n    case \"start\":\r\n      return { x1: clientX, y1: clientY, x2, y2 };\r\n    case \"tr\":\r\n      return { x1, y1: clientY, x2: clientX, y2 };\r\n    case \"bl\":\r\n      return { x1: clientX, y1, x2, y2: clientY };\r\n    case \"br\":\r\n    case \"end\":\r\n      return { x1, y1, x2: clientX, y2: clientY };\r\n    default:\r\n      return null; //should not really get here...\r\n  }\r\n};\r\n\r\nconst getSvgPathFromStroke = (stroke) => {\r\n  if (!stroke.length) return \"\";\r\n\r\n  const d = stroke.reduce(\r\n    (acc, [x0, y0], i, arr) => {\r\n      const [x1, y1] = arr[(i + 1) % arr.length];\r\n      acc.push(x0, y0, (x0 + x1) / 2, (y0 + y1) / 2);\r\n      return acc;\r\n    },\r\n    [\"M\", ...stroke[0], \"Q\"]\r\n  );\r\n\r\n  d.push(\"Z\");\r\n  return d.join(\" \");\r\n};\r\n\r\nconst drawElement = (roughCanvas, context, element) => {\r\n  switch (element.type) {\r\n    case \"line\":\r\n    case \"rectangle\":\r\n      roughCanvas.draw(element.roughElement);\r\n      break;\r\n    case \"pencil\":\r\n      const stroke = getSvgPathFromStroke(getStroke(element.points));\r\n      context.fill(new Path2D(stroke));\r\n      break;\r\n    case \"text\":\r\n      context.textBaseline = \"top\";\r\n      context.font = \"24px sans-serif\";\r\n      context.fillText(element.text, element.x1, element.y1);\r\n      break;\r\n    default:\r\n      throw new Error(`Type not recognised: ${element.type}`);\r\n  }\r\n};\r\n\r\nconst adjustmentRequired = (type) => [\"line\", \"rectangle\"].includes(type);\r\nconst useHistory = (initialState) => {\r\n  const [index, setIndex] = useState(0);\r\n  const [history, setHistory] = useState([initialState]);\r\n  const setState = (action, overwrite = false) => {\r\n    const newState =\r\n      typeof action === \"function\" ? action(history[index]) : action;\r\n    if (overwrite) {\r\n      const historyCopy = [...history];\r\n      historyCopy[index] = newState;\r\n      setHistory(historyCopy);\r\n    } else {\r\n      const updatedState = [...history].slice(0, index + 1);\r\n      setHistory([...updatedState, newState]);\r\n      setIndex((prevState) => prevState + 1);\r\n    }\r\n  };\r\n  const undo = () => index > 0 && setIndex((prevState) => prevState - 1);\r\n  const redo = () =>\r\n    index < history.length - 1 && setIndex((prevState) => prevState + 1);\r\n\r\n  return [history[index], setState, undo, redo];\r\n};\r\nconst App = () => {\r\n  const [elements, setElements, undo, redo] = useHistory([]);\r\n  const [action, setAction] = useState(\"none\");\r\n  const [tool, setTool] = useState(\"text\");\r\n  const [selectedElement, setSelectedElement] = useState(null);\r\n\r\n  useLayoutEffect(() => {\r\n    const canvas = document.getElementById(\"canvas\");\r\n    const context = canvas.getContext(\"2d\");\r\n    context.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    const roughCanvas = rough.canvas(canvas);\r\n\r\n    elements.forEach((element) => {\r\n      if (action === \"writing\" && selectedElement.id === element.id) return;\r\n      drawElement(roughCanvas, context, element);\r\n    });\r\n  }, [elements, action, selectedElement]);\r\n\r\n   const updateElement = (id, x1, y1, x2, y2, type, options) => {\r\n    const elementsCopy = [...elements];\r\n\r\n    switch (type) {\r\n      case \"line\":\r\n      case \"rectangle\":\r\n        elementsCopy[id] = createElement(id, x1, y1, x2, y2, type);\r\n        break;\r\n      case \"pencil\":\r\n        elementsCopy[id].points = [\r\n          ...elementsCopy[id].points,\r\n          { x: x2, y: y2 },\r\n        ];\r\n        break;\r\n      case \"text\":\r\n        const textWidth = document\r\n          .getElementById(\"canvas\")\r\n          .getContext(\"2d\")\r\n          .measureText(options.text).width;\r\n        const textHeight = 24;\r\n        elementsCopy[id] = {\r\n          ...createElement(id, x1, y1, x1 + textWidth, y1 + textHeight, type),\r\n          text: options.text,\r\n        };\r\n        break;\r\n      default:\r\n        throw new Error(`Type not recognised: ${type}`);\r\n    }\r\n\r\n    setElements(elementsCopy, true);\r\n  };\r\n\r\n  const handleMouseDown = (event) => {\r\n    if (action === \"writing\") return;\r\n\r\n    const { clientX, clientY } = event;\r\n    if (tool === \"selection\") {\r\n      const element = getElementAtPosition(clientX, clientY, elements);\r\n      if (element) {\r\n        if (element.type === \"pencil\") {\r\n          const xOffsets = element.points.map((point) => clientX - point.x);\r\n          const yOffsets = element.points.map((point) => clientY - point.y);\r\n          setSelectedElement({ ...element, xOffsets, yOffsets });\r\n        } else {\r\n          const offsetX = clientX - element.x1;\r\n          const offsetY = clientY - element.y1;\r\n          setSelectedElement({ ...element, offsetX, offsetY });\r\n        }\r\n        setElements((prevState) => prevState);\r\n\r\n        if (element.position === \"inside\") {\r\n          setAction(\"moving\");\r\n        } else {\r\n          setAction(\"resizing\");\r\n        }\r\n      }\r\n    } else {\r\n      const id = elements.length;\r\n      const element = createElement(\r\n        id,\r\n        clientX,\r\n        clientY,\r\n        clientX,\r\n        clientY,\r\n        tool\r\n      );\r\n      setElements((prevState) => [...prevState, element]);\r\n      setSelectedElement(element);\r\n\r\n      setAction(tool === \"text\" ? \"writing\" : \"drawing\");\r\n    }\r\n  };\r\n\r\n  const handleMouseMove = (event) => {\r\n    const { clientX, clientY } = event;\r\n\r\n    if (tool === \"selection\") {\r\n      const element = getElementAtPosition(clientX, clientY, elements);\r\n      event.target.style.cursor = element\r\n        ? cursorForPosition(element.position)\r\n        : \"default\";\r\n    }\r\n\r\n    if (action === \"drawing\") {\r\n      const index = elements.length - 1;\r\n      const { x1, y1 } = elements[index];\r\n      updateElement(index, x1, y1, clientX, clientY, tool);\r\n    } else if (action === \"moving\") {\r\n      if (selectedElement.type === \"pencil\") {\r\n        const newPoints = selectedElement.points.map((_, index) => ({\r\n          x: clientX - selectedElement.xOffsets[index],\r\n          y: clientY - selectedElement.yOffsets[index],\r\n        }));\r\n        const elementsCopy = [...elements];\r\n        elementsCopy[selectedElement.id] = {\r\n          ...elementsCopy[selectedElement.id],\r\n          points: newPoints,\r\n        };\r\n        setElements(elementsCopy, true);\r\n      } else {\r\n        const { id, x1, x2, y1, y2, type, offsetX, offsetY } = selectedElement;\r\n        const width = x2 - x1;\r\n        const height = y2 - y1;\r\n        const newX1 = clientX - offsetX;\r\n        const newY1 = clientY - offsetY;\r\n        const options = type === \"text\" ? { text: selectedElement.text } : {};\r\n        updateElement(\r\n          id,\r\n          newX1,\r\n          newY1,\r\n          newX1 + width,\r\n          newY1 + height,\r\n          type,\r\n          options\r\n        );\r\n      }\r\n    } else if (action === \"resizing\") {\r\n      const { id, type, position, ...coordinates } = selectedElement;\r\n      const { x1, y1, x2, y2 } = resizedCoordinates(\r\n        clientX,\r\n        clientY,\r\n        position,\r\n        coordinates\r\n      );\r\n      updateElement(id, x1, y1, x2, y2, type);\r\n    }\r\n  };\r\n\r\n  const handleMouseUp = (event) => {\r\n    const { clientX, clientY } = event;\r\n    if (selectedElement) {\r\n      if (\r\n        selectedElement.type === \"text\" &&\r\n        clientX - selectedElement.offsetX === selectedElement.x1 &&\r\n        clientY - selectedElement.offsetY === selectedElement.y1\r\n      ) {\r\n        setAction(\"writing\");\r\n        return;\r\n      }\r\n\r\n      const index = selectedElement.id;\r\n      const { id, type } = elements[index];\r\n      if (\r\n        (action === \"drawing\" || action === \"resizing\") &&\r\n        adjustmentRequired(type)\r\n      ) {\r\n        const { x1, y1, x2, y2 } = adjustElementCoordinates(elements[index]);\r\n        updateElement(id, x1, y1, x2, y2, type);\r\n      }\r\n    }\r\n\r\n    if (action === \"writing\") return;\r\n\r\n    setAction(\"none\");\r\n    setSelectedElement(null);\r\n  };\r\n\r\n\r\n\r\n  return (\r\n    <div>\r\n      <div style={{ position: \"fixed\" }}>\r\n        <input\r\n          type=\"radio\"\r\n          id=\"selection\"\r\n          checked={tool === \"selection\"}\r\n          onChange={() => setTool(\"selection\")}\r\n        />\r\n        <label htmlFor=\"selection\">Selection</label>\r\n        <input\r\n          type=\"radio\"\r\n          id=\"line\"\r\n          checked={tool === \"line\"}\r\n          onChange={() => setTool(\"line\")}\r\n        />\r\n        <label htmlFor=\"line\">Line</label>\r\n        <input\r\n          type=\"radio\"\r\n          id=\"rectangle\"\r\n          checked={tool === \"rectangle\"}\r\n          onChange={() => setTool(\"rectangle\")}\r\n        />\r\n        <label htmlFor=\"rectangle\">Rectangle</label>\r\n\r\n      </div>\r\n      <div style={{ position: \"fixed\", bottom: 0, padding: 10 }}>\r\n        <button onClick={undo}>Undo</button>\r\n        <button onClick={redo}>Redo</button>\r\n      </div>\r\n\r\n      <canvas\r\n        id=\"canvas\"\r\n        width={window.innerWidth}\r\n        height={window.innerHeight}\r\n        onMouseDown={handleMouseDown}\r\n        onMouseMove={handleMouseMove}\r\n        onMouseUp={handleMouseUp}\r\n      >\r\n        Canvas\r\n      </canvas>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/App.js b/src/App.js
--- a/src/App.js	(revision ba55a8669cacec74c4c47d9b02bda02e8dd7bb44)
+++ b/src/App.js	(date 1675868424372)
@@ -12,10 +12,6 @@
           ? generator.line(x1, y1, x2, y2)
           : generator.rectangle(x1, y1, x2 - x1, y2 - y1);
       return { id, x1, y1, x2, y2, type, roughElement };
-    case "pencil":
-      return { id, type, points: [{ x: x1, y: y1 }] };
-    case "text":
-      return { id, type, x1, y1, x2, y2, text: "" };
     default:
       throw new Error(`Type not recognised: ${type}`);
   }
@@ -126,21 +122,21 @@
   }
 };
 
-const getSvgPathFromStroke = (stroke) => {
-  if (!stroke.length) return "";
-
-  const d = stroke.reduce(
-    (acc, [x0, y0], i, arr) => {
-      const [x1, y1] = arr[(i + 1) % arr.length];
-      acc.push(x0, y0, (x0 + x1) / 2, (y0 + y1) / 2);
-      return acc;
-    },
-    ["M", ...stroke[0], "Q"]
-  );
-
-  d.push("Z");
-  return d.join(" ");
-};
+// const getSvgPathFromStroke = (stroke) => {
+//   if (!stroke.length) return "";
+//
+//   const d = stroke.reduce(
+//     (acc, [x0, y0], i, arr) => {
+//       const [x1, y1] = arr[(i + 1) % arr.length];
+//       acc.push(x0, y0, (x0 + x1) / 2, (y0 + y1) / 2);
+//       return acc;
+//     },
+//     ["M", ...stroke[0], "Q"]
+//   );
+//
+//   d.push("Z");
+//   return d.join(" ");
+// };
 
 const drawElement = (roughCanvas, context, element) => {
   switch (element.type) {
@@ -148,15 +144,15 @@
     case "rectangle":
       roughCanvas.draw(element.roughElement);
       break;
-    case "pencil":
-      const stroke = getSvgPathFromStroke(getStroke(element.points));
-      context.fill(new Path2D(stroke));
-      break;
-    case "text":
-      context.textBaseline = "top";
-      context.font = "24px sans-serif";
-      context.fillText(element.text, element.x1, element.y1);
-      break;
+    // case "pencil":
+    //   const stroke = getSvgPathFromStroke(getStroke(element.points));
+    //   context.fill(new Path2D(stroke));
+    //   break;
+    // case "text":
+    //   context.textBaseline = "top";
+    //   context.font = "24px sans-serif";
+    //   context.fillText(element.text, element.x1, element.y1);
+    //   break;
     default:
       throw new Error(`Type not recognised: ${element.type}`);
   }
@@ -196,6 +192,7 @@
     const context = canvas.getContext("2d");
     context.clearRect(0, 0, canvas.width, canvas.height);
 
+   ///////////////
     const roughCanvas = rough.canvas(canvas);
 
     elements.forEach((element) => {
@@ -212,23 +209,23 @@
       case "rectangle":
         elementsCopy[id] = createElement(id, x1, y1, x2, y2, type);
         break;
-      case "pencil":
-        elementsCopy[id].points = [
-          ...elementsCopy[id].points,
-          { x: x2, y: y2 },
-        ];
-        break;
-      case "text":
-        const textWidth = document
-          .getElementById("canvas")
-          .getContext("2d")
-          .measureText(options.text).width;
-        const textHeight = 24;
-        elementsCopy[id] = {
-          ...createElement(id, x1, y1, x1 + textWidth, y1 + textHeight, type),
-          text: options.text,
-        };
-        break;
+      // case "pencil":
+      //   elementsCopy[id].points = [
+      //     ...elementsCopy[id].points,
+      //     { x: x2, y: y2 },
+      //   ];
+      //   break;
+      // case "text":
+      //   const textWidth = document
+      //     .getElementById("canvas")
+      //     .getContext("2d")
+      //     .measureText(options.text).width;
+      //   const textHeight = 24;
+      //   elementsCopy[id] = {
+      //     ...createElement(id, x1, y1, x1 + textWidth, y1 + textHeight, type),
+      //     text: options.text,
+      //   };
+      //   break;
       default:
         throw new Error(`Type not recognised: ${type}`);
     }
@@ -401,9 +398,8 @@
         onMouseDown={handleMouseDown}
         onMouseMove={handleMouseMove}
         onMouseUp={handleMouseUp}
-      >
-        Canvas
-      </canvas>
+      />
+
     </div>
   );
 };
Index: src/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import React, { useState } from \"react\";\r\nimport { createRoot } from \"react-dom/client\";\r\nimport { Stage, Layer, Rect, Text } from \"react-konva\";\r\nimport App from \"./App\"\r\n\r\nconst container = document.getElementById(\"root\");\r\nconst root = createRoot(container);\r\nroot.render(<App />);\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/index.js b/src/index.js
--- a/src/index.js	(revision ba55a8669cacec74c4c47d9b02bda02e8dd7bb44)
+++ b/src/index.js	(date 1675845429014)
@@ -1,6 +1,6 @@
-import React, { useState } from "react";
+
 import { createRoot } from "react-dom/client";
-import { Stage, Layer, Rect, Text } from "react-konva";
+
 import App from "./App"
 
 const container = document.getElementById("root");
